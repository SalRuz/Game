<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Agar.io Clone</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f0f0f0;
            touch-action: none;
            font-family: Arial, sans-serif;
            cursor: none;
        }
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #gameOverMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            font-size: 48px;
            z-index: 20;
        }
        #restartButton {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #leaderboard {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 8px;
            border-radius: 5px;
            min-width: 120px;
            font-size: 12px;
            z-index: 15;
        }
        #massIndicator {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 8px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 15;
        }
        .player-entry {
            margin: 3px 0;
        }
        .player-entry.player {
            color: red;
            font-weight: bold;
            padding: 1px;
            border: 1px solid rgba(255, 0, 0, 0.5);
            border-radius: 2px;
        }
        #customCursor {
            position: fixed;
            width: 20px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            transform: translate(-50%, -50%);
            display: none;
        }
        @media (orientation: portrait) {
            #orientation-message {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                color: white;
                font-size: 24px;
                z-index: 100;
                text-align: center;
            }
        }
        @media (orientation: landscape) {
            #orientation-message {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="orientation-message">
        Пожалуйста, поверните устройство в горизонтальное положение для игры
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="customCursor"></div>
    <div id="massIndicator">Масса: 20</div>
    <div id="leaderboard"></div>
    <div id="gameOverMenu">
        <div>Game Over!</div>
        <button id="restartButton">Restart</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameOverMenu = document.getElementById('gameOverMenu');
        const restartButton = document.getElementById('restartButton');
        const leaderboardElement = document.getElementById('leaderboard');
        const massIndicator = document.getElementById('massIndicator');
        const customCursor = document.getElementById('customCursor');

        // Устанавливаем размер канваса на весь экран
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Виртуальная игровая карта в 5 раз больше
        const virtualWidth = canvas.width * 5;
        const virtualHeight = canvas.height * 5;

        // Камера (видимая область)
        const camera = {
            x: 0,
            y: 0,
            width: canvas.width,
            height: canvas.height,
            baseZoom: 1, // Базовый зум камеры
            zoom: 1,     // Текущий зум камеры
            minZoom: 0.5, // Минимальный зум
            maxZoom: 2    // Максимальный зум
        };

        // Позиция курсора мыши
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;

        // Список имен для ботов
        const botNames = [
            "Bot_Alpha", "Bot_Beta", "Bot_Gamma", "Bot_Delta", "Bot_Epsilon",
            "Bot_Zeta", "Bot_Eta", "Bot_Theta", "Bot_Iota", "Bot_Kappa",
            "Bot_Lambda", "Bot_Mu", "Bot_Nu", "Bot_Xi", "Bot_Omicron",
            "Bot_Pi", "Bot_Rho", "Bot_Sigma", "Bot_Tau", "Bot_Upsilon",
            "Bot_Phi", "Bot_Chi", "Bot_Psi", "Bot_Omega", "Bot_Ares",
            "Bot_Zeus", "Bot_Hera", "Bot_Poseidon", "Bot_Athena", "Bot_Apollo",
            "Bot_Artemis", "Bot_Hermes", "Bot_Dionysus", "Bot_Aphrodite", "Bot_Hades",
            "Bot_Hephaestus", "Bot_Demeter", "Bot_Hestia", "Bot_Nike", "Bot_Janus",
            "Bot_Chronos", "Bot_Gaia", "Bot_Uranus", "Bot_Atlas", "Bot_Prometheus",
            "Bot_Orion", "Bot_Hercules", "Bot_Perseus", "Bot_Theseus", "Bot_Odysseus"
        ];

        // Мелкие частицы еды
        const foodParticles = [];
        const FOOD_COUNT = 500; // Количество частиц еды

        // Инициализация частиц еды
        function initFood() {
            for (let i = 0; i < FOOD_COUNT; i++) {
                foodParticles.push({
                    x: Math.random() * virtualWidth,
                    y: Math.random() * virtualHeight,
                    radius: 2,
                    color: getRandomFoodColor()
                });
            }
        }

        // Случайный цвет для еды
        function getRandomFoodColor() {
            const colors = [
                '#FF5252', '#FF4081', '#E040FB', '#7C4DFF', '#536DFE',
                '#448AFF', '#40C4FF', '#18FFFF', '#64FFDA', '#69F0AE',
                '#B2FF59', '#EEFF41', '#FFFF00', '#FFD740', '#FFAB40', '#FF6E40'
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // Главный игрок (начальный размер 20 поинтов)
        const player = {
            x: virtualWidth / 2,
            y: virtualHeight / 2,
            radius: Math.sqrt(20 / Math.PI), // Начальный размер для 20 поинтов
            color: '#ff0000',
            speed: 5,
            dx: 0,
            dy: 0,
            name: "Player",
            score: 20 // Начальный счет 20
        };

        // Боты (начальный размер 20 поинтов)
        const bots = [];
        const BOT_COUNT = 50; // Количество ботов оставлено прежним

        // Инициализация ботов
        function initBots() {
            for (let i = 0; i < BOT_COUNT; i++) {
                bots.push({
                    x: Math.random() * virtualWidth,
                    y: Math.random() * virtualHeight,
                    radius: Math.sqrt(20 / Math.PI), // Начальный размер для 20 поинтов
                    color: `#${Math.floor(Math.random()*16777215).toString(16)}`,
                    speed: 1 + Math.random() * 1,
                    dx: (Math.random() - 0.5) * 2,
                    dy: (Math.random() - 0.5) * 2,
                    name: botNames[i % botNames.length],
                    score: 20 // Начальный счет 20
                });
            }
        }

        // Управление курсором мыши
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            
            // Обновление позиции кастомного курсора
            customCursor.style.display = 'block';
            customCursor.style.left = e.clientX + 'px';
            customCursor.style.top = e.clientY + 'px';
        });

        canvas.addEventListener('mouseleave', () => {
            customCursor.style.display = 'none';
        });

        // Отрисовка фона в клетку
        function drawGrid() {
            const gridSize = 50;
            const startX = camera.x % gridSize;
            const startY = camera.y % gridSize;

            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;

            for (let x = -startX; x < camera.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, camera.height);
                ctx.stroke();
            }

            for (let y = -startY; y < camera.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(camera.width, y);
                ctx.stroke();
            }
        }

        // Обновление позиции камеры (зависит от массы игрока)
        function updateCamera() {
            // Вычисляем зум камеры на основе массы игрока
            // Чем больше масса, тем больше обзор (меньше зум)
            camera.zoom = Math.max(camera.minZoom, Math.min(camera.maxZoom, 100 / player.score));
            
            // Обновляем размер камеры на основе зума
            camera.width = canvas.width / camera.zoom;
            camera.height = canvas.height / camera.zoom;
            
            // Позиция камеры следует за игроком
            camera.x = player.x - camera.width / 2;
            camera.y = player.y - camera.height / 2;

            // Ограничение по границам виртуальной карты
            if (camera.x < 0) camera.x = 0;
            if (camera.y < 0) camera.y = 0;
            if (camera.x + camera.width > virtualWidth) camera.x = virtualWidth - camera.width;
            if (camera.y + camera.height > virtualHeight) camera.y = virtualHeight - camera.height;
        }

        // Обновление позиции игрока (следование за курсором мыши)
        function updatePlayer() {
            // Вычисляем направление к курсору мыши
            const targetX = camera.x + mouseX / camera.zoom;
            const targetY = camera.y + mouseY / camera.zoom;
            
            const dx = targetX - player.x;
            const dy = targetY - player.y;
            
            // Вычисляем расстояние до цели
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 5) {
                // Нормализуем направление и умножаем на скорость
                // Скорость уменьшается с увеличением массы
                const speed = Math.max(2, player.speed * (30 / player.score));
                player.dx = (dx / distance) * speed;
                player.dy = (dy / distance) * speed;
                
                player.x += player.dx;
                player.y += player.dy;
            }

            // Ограничение по границам виртуальной карты
            if (player.x - player.radius < 0) player.x = player.radius;
            if (player.x + player.radius > virtualWidth) player.x = virtualWidth - player.radius;
            if (player.y - player.radius < 0) player.y = player.radius;
            if (player.y + player.radius > virtualHeight) player.y = virtualHeight - player.radius;
        }

        // Обновление позиции ботов
        function updateBots() {
            bots.forEach(bot => {
                bot.x += bot.dx;
                bot.y += bot.dy;

                // Случайное изменение направления
                if (Math.random() < 0.02) {
                    bot.dx = (Math.random() - 0.5) * bot.speed;
                    bot.dy = (Math.random() - 0.5) * bot.speed;
                }

                // Ограничение по границам виртуальной карты
                if (bot.x - bot.radius < 0) {
                    bot.x = bot.radius;
                    bot.dx *= -1;
                }
                if (bot.x + bot.radius > virtualWidth) {
                    bot.x = virtualWidth - bot.radius;
                    bot.dx *= -1;
                }
                if (bot.y - bot.radius < 0) {
                    bot.y = bot.radius;
                    bot.dy *= -1;
                }
                if (bot.y + bot.radius > virtualHeight) {
                    bot.y = virtualHeight - bot.radius;
                    bot.dy *= -1;
                }
            });

            // Проверка столкновений между ботами
            for (let i = 0; i < bots.length; i++) {
                for (let j = i + 1; j < bots.length; j++) {
                    const bot1 = bots[i];
                    const bot2 = bots[j];
                    const dx = bot1.x - bot2.x;
                    const dy = bot1.y - bot2.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < bot1.radius + bot2.radius) {
                        if (bot1.score > bot2.score) {
                            // Бот1 съедает бота2
                            bot1.score += bot2.score;
                            bot1.radius = Math.sqrt(bot1.score / Math.PI);
                            bots.splice(j, 1);
                            respawnBot();
                        } else if (bot2.score > bot1.score) {
                            // Бот2 съедает бота1
                            bot2.score += bot1.score;
                            bot2.radius = Math.sqrt(bot2.score / Math.PI);
                            bots.splice(i, 1);
                            respawnBot();
                        }
                    }
                }
            }
        }

        // Проверка сбора еды
        function checkFoodCollection() {
            // Проверка для игрока
            for (let i = foodParticles.length - 1; i >= 0; i--) {
                const food = foodParticles[i];
                const dx = player.x - food.x;
                const dy = player.y - food.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < player.radius + food.radius) {
                    player.score += 1;
                    player.radius = Math.sqrt(player.score / Math.PI);
                    foodParticles.splice(i, 1);
                }
            }
            
            // Проверка для ботов
            bots.forEach(bot => {
                for (let i = foodParticles.length - 1; i >= 0; i--) {
                    const food = foodParticles[i];
                    const dx = bot.x - food.x;
                    const dy = bot.y - food.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < bot.radius + food.radius) {
                        bot.score += 1;
                        bot.radius = Math.sqrt(bot.score / Math.PI);
                        foodParticles.splice(i, 1);
                    }
                }
            });
        }

        // Добавление новой еды (20 штук каждую секунду)
        function spawnFoodRegularly() {
            setInterval(() => {
                for (let i = 0; i < 20; i++) {
                    foodParticles.push({
                        x: Math.random() * virtualWidth,
                        y: Math.random() * virtualHeight,
                        radius: 2,
                        color: getRandomFoodColor()
                    });
                }
            }, 1000);
        }

        // Респаун бота
        function respawnBot() {
            bots.push({
                x: Math.random() * virtualWidth,
                y: Math.random() * virtualHeight,
                radius: Math.sqrt(20 / Math.PI), // Начальный размер для 20 поинтов
                color: `#${Math.floor(Math.random()*16777215).toString(16)}`,
                speed: 1 + Math.random() * 1,
                dx: (Math.random() - 0.5) * 2,
                dy: (Math.random() - 0.5) * 2,
                name: botNames[Math.floor(Math.random() * botNames.length)],
                score: 20 // Начальный счет 20
            });
        }

        // Проверка столкновений игрока с ботами
        function checkCollisions() {
            for (let i = 0; i < bots.length; i++) {
                const bot = bots[i];
                const dx = player.x - bot.x;
                const dy = player.y - bot.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < player.radius + bot.radius) {
                    if (player.score > bot.score) {
                        // Игрок съедает бота
                        player.score += bot.score;
                        player.radius = Math.sqrt(player.score / Math.PI);
                        bots.splice(i, 1);
                        respawnBot();
                    } else {
                        // Бот съедает игрока
                        showGameOverMenu();
                        return;
                    }
                }
            }
        }

        // Обновление таблицы лидеров (без отображения массы)
        function updateLeaderboard() {
            // Создаем массив всех объектов (боты + игрок)
            const allPlayers = [...bots.map(bot => ({
                name: bot.name,
                isPlayer: false
            })), {
                name: player.name,
                isPlayer: true
            }];
            
            // Сортируем по очкам (по убыванию)
            allPlayers.sort((a, b) => {
                const aScore = a.isPlayer ? player.score : bots.find(b => b.name === a.name)?.score || 0;
                const bScore = b.isPlayer ? player.score : bots.find(b => b.name === b.name)?.score || 0;
                return bScore - aScore;
            });
            
            // Берем топ-10
            const topPlayers = allPlayers.slice(0, 10);
            
            // Очищаем и обновляем таблицу лидеров
            leaderboardElement.innerHTML = '<h3>Top 10</h3>';
            topPlayers.forEach((p, index) => {
                const entry = document.createElement('div');
                entry.className = 'player-entry' + (p.isPlayer ? ' player' : '');
                entry.textContent = `${index + 1}. ${p.name}`;
                leaderboardElement.appendChild(entry);
            });
        }

        // Обновление индикатора массы
        function updateMassIndicator() {
            massIndicator.textContent = `Масса: ${Math.round(player.score)}`;
        }

        // Показать меню поражения
        function showGameOverMenu() {
            gameOverMenu.style.display = 'flex';
        }

        // Скрыть меню поражения
        function hideGameOverMenu() {
            gameOverMenu.style.display = 'none';
        }

        // Рестарт игры
        function restartGame() {
            player.x = virtualWidth / 2;
            player.y = virtualHeight / 2;
            player.radius = Math.sqrt(20 / Math.PI);
            player.score = 20;
            
            // Очищаем ботов и создаем заново
            bots.length = 0;
            initBots();
            
            // Очищаем и заново генерируем еду
            foodParticles.length = 0;
            initFood();
            
            hideGameOverMenu();
        }

        // Отрисовка
        function draw() {
            // Очищаем canvas
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Сохраняем текущее состояние контекста
            ctx.save();
            
            // Применяем масштабирование (зум камеры)
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(-camera.x, -camera.y);

            drawGrid();

            // Отрисовка частиц еды
            foodParticles.forEach(food => {
                ctx.beginPath();
                ctx.arc(food.x, food.y, food.radius, 0, Math.PI * 2);
                ctx.fillStyle = food.color;
                ctx.fill();
                ctx.closePath();
            });

            // Отрисовка ботов
            bots.forEach(bot => {
                ctx.beginPath();
                ctx.arc(bot.x, bot.y, bot.radius, 0, Math.PI * 2);
                ctx.fillStyle = bot.color;
                ctx.fill();
                ctx.closePath();
                
                // Отображение имени бота
                ctx.fillStyle = '#000000';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(bot.name, bot.x, bot.y + bot.radius + 15);
            });

            // Отрисовка игрока
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            ctx.fillStyle = player.color;
            ctx.fill();
            ctx.closePath();
            
            // Отображение имени игрока
            ctx.fillStyle = '#000000';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(player.name, player.x, player.y + player.radius + 15);
            
            // Восстанавливаем состояние контекста
            ctx.restore();
        }

        // Кнопка рестарта
        restartButton.addEventListener('click', restartGame);

        // Основной игровой цикл
        function gameLoop() {
            updatePlayer();
            updateCamera();
            updateBots();
            checkFoodCollection();
            checkCollisions();
            updateLeaderboard();
            updateMassIndicator();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Инициализация игры
        function initGame() {
            initBots();
            initFood();
            spawnFoodRegularly();
            gameLoop();
        }

        // Запуск игры при загрузке
        window.addEventListener('load', initGame);

        // Обработка изменения размера окна
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>
