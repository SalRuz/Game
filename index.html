<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Agar.io Clone</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f0f0f0;
            touch-action: none;
            font-family: Arial, sans-serif;
        }
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #gameOverMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            font-size: 48px;
            z-index: 20;
        }
        #restartButton {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #leaderboard {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 8px;
            border-radius: 5px;
            min-width: 120px;
            font-size: 12px;
            z-index: 15;
        }
        #massIndicator {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 8px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 15;
        }
        .player-entry {
            margin: 3px 0;
        }
        .player-entry.player {
            color: red;
            font-weight: bold;
            padding: 1px;
            border: 1px solid rgba(255, 0, 0, 0.5);
            border-radius: 2px;
        }
        @media (orientation: portrait) {
            #orientation-message {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                color: white;
                font-size: 24px;
                z-index: 100;
                text-align: center;
            }
        }
        @media (orientation: landscape) {
            #orientation-message {
                display: none;
            }
        }
        #controlsInfo {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 8px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 15;
        }
    </style>
</head>
<body>
    <div id="orientation-message">
        Пожалуйста, поверните устройство в горизонтальное положение для игры
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="massIndicator">Масса: 20</div>
    <div id="leaderboard"></div>
    <div id="controlsInfo">Управление: W - выплюнуть массу, Пробел - разделиться</div>
    <div id="gameOverMenu">
        <div>Game Over!</div>
        <button id="restartButton">Restart</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameOverMenu = document.getElementById('gameOverMenu');
        const restartButton = document.getElementById('restartButton');
        const leaderboardElement = document.getElementById('leaderboard');
        const massIndicator = document.getElementById('massIndicator');

        // Устанавливаем размер канваса на весь экран
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Виртуальная игровая карта в 5 раз больше
        const virtualWidth = canvas.width * 5;
        const virtualHeight = canvas.height * 5;

        // Камера (видимая область)
        const camera = {
            x: 0,
            y: 0,
            width: canvas.width,
            height: canvas.height,
            baseZoom: 1, // Базовый зум камеры
            zoom: 1,     // Текущий зум камеры
            minZoom: 0.5, // Минимальный зум
            maxZoom: 2    // Максимальный зум
        };

        // Позиция курсора мыши
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;

        // Список имен для ботов
        const botNames = [
            "Bot_Alpha", "Bot_Beta", "Bot_Gamma", "Bot_Delta", "Bot_Epsilon",
            "Bot_Zeta", "Bot_Eta", "Bot_Theta", "Bot_Iota", "Bot_Kappa",
            "Bot_Lambda", "Bot_Mu", "Bot_Nu", "Bot_Xi", "Bot_Omicron",
            "Bot_Pi", "Bot_Rho", "Bot_Sigma", "Bot_Tau", "Bot_Upsilon",
            "Bot_Phi", "Bot_Chi", "Bot_Psi", "Bot_Omega", "Bot_Ares",
            "Bot_Zeus", "Bot_Hera", "Bot_Poseidon", "Bot_Athena", "Bot_Apollo",
            "Bot_Artemis", "Bot_Hermes", "Bot_Dionysus", "Bot_Aphrodite", "Bot_Hades",
            "Bot_Hephaestus", "Bot_Demeter", "Bot_Hestia", "Bot_Nike", "Bot_Janus",
            "Bot_Chronos", "Bot_Gaia", "Bot_Uranus", "Bot_Atlas", "Bot_Prometheus",
            "Bot_Orion", "Bot_Hercules", "Bot_Perseus", "Bot_Theseus", "Bot_Odysseus"
        ];

        // Мелкие частицы еды
        const foodParticles = [];
        const FOOD_COUNT = 500; // Количество частиц еды

        // Выплюнутые частицы
        const ejectedParticles = [];

        // Клавиши управления
        const keys = {};

        // Инициализация частиц еды
        function initFood() {
            for (let i = 0; i < FOOD_COUNT; i++) {
                foodParticles.push({
                    x: Math.random() * virtualWidth,
                    y: Math.random() * virtualHeight,
                    radius: 2,
                    color: getRandomFoodColor()
                });
            }
        }

        // Случайный цвет для еды
        function getRandomFoodColor() {
            const colors = [
                '#FF5252', '#FF4081', '#E040FB', '#7C4DFF', '#536DFE',
                '#448AFF', '#40C4FF', '#18FFFF', '#64FFDA', '#69F0AE',
                '#B2FF59', '#EEFF41', '#FFFF00', '#FFD740', '#FFAB40', '#FF6E40'
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // Главный игрок (начальный размер 20 поинтов)
        const player = {
            x: virtualWidth / 2,
            y: virtualHeight / 2,
            radius: Math.sqrt(20 / Math.PI), // Начальный размер для 20 поинтов
            color: '#ff0000',
            speed: 8, // Начальная скорость увеличена
            dx: 0,
            dy: 0,
            name: "Player",
            score: 20, // Начальный счет 20
            cells: [], // Массив для частей игрока
            lastSplitTime: 0, // Время последнего разделения
            isSplitting: false // Флаг разделения
        };

        // Инициализация игрока как одной клетки
        player.cells.push({
            x: player.x,
            y: player.y,
            radius: player.radius,
            color: player.color,
            dx: 0,
            dy: 0,
            score: player.score
        });

        // Боты (начальный размер 20 поинтов)
        const bots = [];
        const BOT_COUNT = 50; // Количество ботов оставлено прежним

        // Инициализация ботов
        function initBots() {
            for (let i = 0; i < BOT_COUNT; i++) {
                const botScore = 20;
                bots.push({
                    x: Math.random() * virtualWidth,
                    y: Math.random() * virtualHeight,
                    radius: Math.sqrt(botScore / Math.PI),
                    color: `#${Math.floor(Math.random()*16777215).toString(16)}`,
                    speed: 3 + Math.random() * 2,
                    dx: (Math.random() - 0.5) * 2,
                    dy: (Math.random() - 0.5) * 2,
                    name: botNames[i % botNames.length],
                    score: botScore,
                    cells: [] // Массив для частей ботов
                });
                
                // Инициализация бота как одной клетки
                bots[i].cells.push({
                    x: bots[i].x,
                    y: bots[i].y,
                    radius: bots[i].radius,
                    color: bots[i].color,
                    dx: bots[i].dx,
                    dy: bots[i].dy,
                    score: bots[i].score
                });
            }
        }

        // Управление курсором мыши
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        // Обработка нажатий клавиш
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            // Выплевывание массы по клавише W
            if (e.key === 'w' || e.key === 'W' || e.key === 'ц' || e.key === 'Ц') {
                ejectMass();
            }
            
            // Разделение по пробелу
            if (e.key === ' ') {
                splitPlayer();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Выплевывание массы
        function ejectMass() {
            // Проверяем, что у игрока достаточно массы (минимум 20)
            if (player.score >= 20) {
                // Находим центр всех клеток игрока
                let centerX = 0;
                let centerY = 0;
                
                player.cells.forEach(cell => {
                    centerX += cell.x;
                    centerY += cell.y;
                });
                
                centerX /= player.cells.length;
                centerY /= player.cells.length;
                
                // Направление выплевывания - к курсору мыши
                const dx = mouseX - centerX;
                const dy = mouseY - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    // Нормализуем направление
                    const normDx = dx / distance;
                    const normDy = dy / distance;
                    
                    // Создаем выплюнутую частицу
                    ejectedParticles.push({
                        x: centerX,
                        y: centerY,
                        radius: Math.sqrt(10 / Math.PI), // Размер 10 единиц
                        color: player.color,
                        dx: normDx * 10, // Скорость вылета
                        dy: normDy * 10,
                        score: 10
                    });
                    
                    // Уменьшаем массу игрока
                    player.score -= 10;
                    
                    // Обновляем массу всех клеток пропорционально
                    const totalMass = player.cells.reduce((sum, cell) => sum + cell.score, 0);
                    player.cells.forEach(cell => {
                        cell.score = (cell.score / totalMass) * player.score;
                        cell.radius = Math.sqrt(cell.score / Math.PI);
                    });
                }
            }
        }

        // Разделение игрока
        function splitPlayer() {
            // Проверяем, что у игрока достаточно массы и меньше 16 частей
            if (player.score >= 20 && player.cells.length < 16) {
                // Находим центр всех клеток игрока
                let centerX = 0;
                let centerY = 0;
                
                player.cells.forEach(cell => {
                    centerX += cell.x;
                    centerY += cell.y;
                });
                
                centerX /= player.cells.length;
                centerY /= player.cells.length;
                
                // Направление разделения - к курсору мыши
                const dx = mouseX - centerX;
                const dy = mouseY - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    // Нормализуем направление
                    const normDx = dx / distance;
                    const normDy = dy / distance;
                    
                    // Создаем новую клетку из самой большой существующей
                    let largestCell = player.cells[0];
                    for (let i = 1; i < player.cells.length; i++) {
                        if (player.cells[i].score > largestCell.score) {
                            largestCell = player.cells[i];
                        }
                    }
                    
                    // Проверяем, что клетка достаточно большая для разделения
                    if (largestCell.score >= 20) {
                        // Уменьшаем исходную клетку вдвое
                        const newScore = largestCell.score / 2;
                        largestCell.score = newScore;
                        largestCell.radius = Math.sqrt(newScore / Math.PI);
                        
                        // Создаем новую клетку
                        const newCell = {
                            x: largestCell.x,
                            y: largestCell.y,
                            radius: Math.sqrt(newScore / Math.PI),
                            color: player.color,
                            dx: normDx * 15, // Скорость разделения
                            dy: normDy * 15,
                            score: newScore
                        };
                        
                        player.cells.push(newCell);
                        player.lastSplitTime = Date.now();
                        player.isSplitting = true;
                    }
                }
            }
        }

        // Объединение клеток игрока после разделения
        function mergePlayerCells() {
            if (player.isSplitting && Date.now() - player.lastSplitTime > 30000) {
                // Находим центр всех клеток
                let centerX = 0;
                let centerY = 0;
                
                player.cells.forEach(cell => {
                    centerX += cell.x;
                    centerY += cell.y;
                });
                
                centerX /= player.cells.length;
                centerY /= player.cells.length;
                
                // Объединяем все клетки в одну
                player.cells = [{
                    x: centerX,
                    y: centerY,
                    radius: Math.sqrt(player.score / Math.PI),
                    color: player.color,
                    dx: 0,
                    dy: 0,
                    score: player.score
                }];
                
                player.isSplitting = false;
            }
        }

        // Отрисовка фона в клетку
        function drawGrid() {
            const gridSize = 50;
            const startX = camera.x % gridSize;
            const startY = camera.y % gridSize;

            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;

            for (let x = -startX; x < camera.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, camera.height);
                ctx.stroke();
            }

            for (let y = -startY; y < camera.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(camera.width, y);
                ctx.stroke();
            }
        }

        // Обновление позиции камеры (зависит от массы игрока)
        function updateCamera() {
            // Вычисляем зум камеры на основе массы игрока
            // Плавное увеличение обзора до массы 21500
            if (player.score < 21500) {
                camera.zoom = Math.max(camera.minZoom, Math.min(camera.maxZoom, 1 + player.score / 10000));
            } else {
                camera.zoom = camera.maxZoom;
            }
            
            // Обновляем размер камеры на основе зума
            camera.width = canvas.width / camera.zoom;
            camera.height = canvas.height / camera.zoom;
            
            // Находим центр всех клеток игрока
            let centerX = 0;
            let centerY = 0;
            
            player.cells.forEach(cell => {
                centerX += cell.x;
                centerY += cell.y;
            });
            
            centerX /= player.cells.length;
            centerY /= player.cells.length;
            
            // Позиция камеры следует за центром клеток игрока
            camera.x = centerX - camera.width / 2;
            camera.y = centerY - camera.height / 2;

            // Ограничение по границам виртуальной карты
            if (camera.x < 0) camera.x = 0;
            if (camera.y < 0) camera.y = 0;
            if (camera.x + camera.width > virtualWidth) camera.x = virtualWidth - camera.width;
            if (camera.y + camera.height > virtualHeight) camera.y = virtualHeight - camera.height;
        }

        // Обновление позиции игрока (следование за курсором мыши)
        function updatePlayer() {
            // Вычисляем центр всех клеток игрока
            let centerX = 0;
            let centerY = 0;
            
            player.cells.forEach(cell => {
                centerX += cell.x;
                centerY += cell.y;
            });
            
            centerX /= player.cells.length;
            centerY /= player.cells.length;
            
            // Вычисляем направление к курсору мыши
            const targetX = camera.x + mouseX / camera.zoom;
            const targetY = camera.y + mouseY / camera.zoom;
            
            const dx = targetX - centerX;
            const dy = targetY - centerY;
            
            // Вычисляем расстояние до цели
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 5) {
                // Нормализуем направление
                const normDx = dx / distance;
                const normDy = dy / distance;
                
                // Вычисляем скорость (зависит от массы, но не ниже минимальной)
                const baseSpeed = 8; // Базовая скорость
                const speed = Math.max(2, baseSpeed * (30 / Math.max(30, player.score)));
                
                // Если масса больше 21500, фиксируем скорость
                const finalSpeed = player.score > 21500 ? 2 : speed;
                
                // Обновляем направление для каждой клетки
                player.cells.forEach(cell => {
                    cell.dx = normDx * finalSpeed;
                    cell.dy = normDy * finalSpeed;
                    
                    cell.x += cell.dx;
                    cell.y += cell.dy;
                    
                    // Ограничение по границам виртуальной карты
                    if (cell.x - cell.radius < 0) cell.x = cell.radius;
                    if (cell.x + cell.radius > virtualWidth) cell.x = virtualWidth - cell.radius;
                    if (cell.y - cell.radius < 0) cell.y = cell.radius;
                    if (cell.y + cell.radius > virtualHeight) cell.y = virtualHeight - cell.radius;
                });
            }
            
            // Объединение клеток после разделения
            mergePlayerCells();
        }

        // Обновление выплюнутых частиц
        function updateEjectedParticles() {
            for (let i = ejectedParticles.length - 1; i >= 0; i--) {
                const particle = ejectedParticles[i];
                
                // Двигаем частицу
                particle.x += particle.dx;
                particle.y += particle.dy;
                
                // Замедляем частицу
                particle.dx *= 0.95;
                particle.dy *= 0.95;
                
                // Удаляем частицу, если она почти остановилась
                if (Math.abs(particle.dx) < 0.1 && Math.abs(particle.dy) < 0.1) {
                    ejectedParticles.splice(i, 1);
                }
                
                // Ограничение по границам виртуальной карты
                if (particle.x - particle.radius < 0) {
                    particle.x = particle.radius;
                    particle.dx *= -0.5;
                }
                if (particle.x + particle.radius > virtualWidth) {
                    particle.x = virtualWidth - particle.radius;
                    particle.dx *= -0.5;
                }
                if (particle.y - particle.radius < 0) {
                    particle.y = particle.radius;
                    particle.dy *= -0.5;
                }
                if (particle.y + particle.radius > virtualHeight) {
                    particle.y = virtualHeight - particle.radius;
                    particle.dy *= -0.5;
                }
            }
        }

        // Обновление позиции ботов
        function updateBots() {
            bots.forEach(bot => {
                // Обновляем центр бота
                let centerX = 0;
                let centerY = 0;
                
                bot.cells.forEach(cell => {
                    centerX += cell.x;
                    centerY += cell.y;
                });
                
                centerX /= bot.cells.length;
                centerY /= bot.cells.length;
                
                bot.x = centerX;
                bot.y = centerY;
                
                // Случайное изменение направления
                if (Math.random() < 0.02) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = bot.speed;
                    
                    bot.cells.forEach(cell => {
                        cell.dx = Math.cos(angle) * speed;
                        cell.dy = Math.sin(angle) * speed;
                    });
                }
                
                // Двигаем все клетки бота
                bot.cells.forEach(cell => {
                    cell.x += cell.dx;
                    cell.y += cell.dy;
                    
                    // Ограничение по границам виртуальной карты
                    if (cell.x - cell.radius < 0) {
                        cell.x = cell.radius;
                        cell.dx *= -1;
                    }
                    if (cell.x + cell.radius > virtualWidth) {
                        cell.x = virtualWidth - cell.radius;
                        cell.dx *= -1;
                    }
                    if (cell.y - cell.radius < 0) {
                        cell.y = cell.radius;
                        cell.dy *= -1;
                    }
                    if (cell.y + cell.radius > virtualHeight) {
                        cell.y = virtualHeight - cell.radius;
                        cell.dy *= -1;
                    }
                });
            });

            // Проверка столкновений между ботами
            for (let i = 0; i < bots.length; i++) {
                for (let j = i + 1; j < bots.length; j++) {
                    const bot1 = bots[i];
                    const bot2 = bots[j];
                    
                    // Проверяем столкновения между всеми клетками ботов
                    for (let k = 0; k < bot1.cells.length; k++) {
                        for (let l = 0; l < bot2.cells.length; l++) {
                            const cell1 = bot1.cells[k];
                            const cell2 = bot2.cells[l];
                            
                            const dx = cell1.x - cell2.x;
                            const dy = cell1.y - cell2.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < cell1.radius + cell2.radius) {
                                if (cell1.score > cell2.score) {
                                    // Клетка1 съедает клетку2
                                    cell1.score += cell2.score;
                                    cell1.radius = Math.sqrt(cell1.score / Math.PI);
                                    bot2.cells.splice(l, 1);
                                    
                                    // Если у бота не осталось клеток, респавним его
                                    if (bot2.cells.length === 0) {
                                        bots.splice(j, 1);
                                        respawnBot();
                                    }
                                } else if (cell2.score > cell1.score) {
                                    // Клетка2 съедает клетку1
                                    cell2.score += cell1.score;
                                    cell2.radius = Math.sqrt(cell2.score / Math.PI);
                                    bot1.cells.splice(k, 1);
                                    
                                    // Если у бота не осталось клеток, респавним его
                                    if (bot1.cells.length === 0) {
                                        bots.splice(i, 1);
                                        respawnBot();
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        // Проверка сбора еды
        function checkFoodCollection() {
            // Проверка для игрока
            for (let i = foodParticles.length - 1; i >= 0; i--) {
                const food = foodParticles[i];
                
                for (let j = 0; j < player.cells.length; j++) {
                    const cell = player.cells[j];
                    const dx = cell.x - food.x;
                    const dy = cell.y - food.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < cell.radius + food.radius) {
                        cell.score += 1;
                        player.score += 1;
                        cell.radius = Math.sqrt(cell.score / Math.PI);
                        foodParticles.splice(i, 1);
                        break;
                    }
                }
            }
            
            // Проверка для ботов
            bots.forEach(bot => {
                for (let i = foodParticles.length - 1; i >= 0; i--) {
                    const food = foodParticles[i];
                    
                    for (let j = 0; j < bot.cells.length; j++) {
                        const cell = bot.cells[j];
                        const dx = cell.x - food.x;
                        const dy = cell.y - food.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < cell.radius + food.radius) {
                            cell.score += 1;
                            bot.score += 1;
                            cell.radius = Math.sqrt(cell.score / Math.PI);
                            foodParticles.splice(i, 1);
                            break;
                        }
                    }
                }
            });
            
            // Проверка сбора выплюнутых частиц
            for (let i = ejectedParticles.length - 1; i >= 0; i--) {
                const particle = ejectedParticles[i];
                
                // Проверка для игрока
                for (let j = 0; j < player.cells.length; j++) {
                    const cell = player.cells[j];
                    const dx = cell.x - particle.x;
                    const dy = cell.y - particle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < cell.radius + particle.radius && cell.score > 10) {
                        cell.score += particle.score;
                        player.score += particle.score;
                        cell.radius = Math.sqrt(cell.score / Math.PI);
                        ejectedParticles.splice(i, 1);
                        break;
                    }
                }
                
                // Проверка для ботов
                if (i < ejectedParticles.length) { // Проверяем, что частица еще существует
                    for (let j = 0; j < bots.length; j++) {
                        const bot = bots[j];
                        
                        for (let k = 0; k < bot.cells.length; k++) {
                            const cell = bot.cells[k];
                            const dx = cell.x - particle.x;
                            const dy = cell.y - particle.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < cell.radius + particle.radius && cell.score > 10) {
                                cell.score += particle.score;
                                bot.score += particle.score;
                                cell.radius = Math.sqrt(cell.score / Math.PI);
                                ejectedParticles.splice(i, 1);
                                break;
                            }
                        }
                        
                        if (i >= ejectedParticles.length) break; // Выходим, если частица была удалена
                    }
                }
            }
        }

        // Добавление новой еды (20 штук каждую секунду)
        function spawnFoodRegularly() {
            setInterval(() => {
                for (let i = 0; i < 20; i++) {
                    foodParticles.push({
                        x: Math.random() * virtualWidth,
                        y: Math.random() * virtualHeight,
                        radius: 2,
                        color: getRandomFoodColor()
                    });
                }
            }, 1000);
        }

        // Респаун бота
        function respawnBot() {
            const botScore = 20;
            const newBot = {
                x: Math.random() * virtualWidth,
                y: Math.random() * virtualHeight,
                radius: Math.sqrt(botScore / Math.PI),
                color: `#${Math.floor(Math.random()*16777215).toString(16)}`,
                speed: 3 + Math.random() * 2,
                dx: (Math.random() - 0.5) * 2,
                dy: (Math.random() - 0.5) * 2,
                name: botNames[Math.floor(Math.random() * botNames.length)],
                score: botScore,
                cells: []
            };
            
            newBot.cells.push({
                x: newBot.x,
                y: newBot.y,
                radius: newBot.radius,
                color: newBot.color,
                dx: newBot.dx,
                dy: newBot.dy,
                score: newBot.score
            });
            
            bots.push(newBot);
        }

        // Проверка столкновений игрока с ботами
        function checkCollisions() {
            for (let i = 0; i < bots.length; i++) {
                const bot = bots[i];
                
                for (let j = 0; j < bot.cells.length; j++) {
                    const botCell = bot.cells[j];
                    
                    for (let k = 0; k < player.cells.length; k++) {
                        const playerCell = player.cells[k];
                        
                        const dx = playerCell.x - botCell.x;
                        const dy = playerCell.y - botCell.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < playerCell.radius + botCell.radius) {
                            if (playerCell.score > botCell.score * 1.1) {
                                // Игрок съедает бота
                                playerCell.score += botCell.score;
                                player.score += botCell.score;
                                playerCell.radius = Math.sqrt(playerCell.score / Math.PI);
                                bot.cells.splice(j, 1);
                                
                                // Если у бота не осталось клеток, респавним его
                                if (bot.cells.length === 0) {
                                    bots.splice(i, 1);
                                    respawnBot();
                                }
                            } else if (botCell.score > playerCell.score * 1.1) {
                                // Бот съедает игрока
                                botCell.score += playerCell.score;
                                bot.score += playerCell.score;
                                botCell.radius = Math.sqrt(botCell.score / Math.PI);
                                player.cells.splice(k, 1);
                                
                                // Если у игрока не осталось клеток, игра окончена
                                if (player.cells.length === 0) {
                                    showGameOverMenu();
                                    return;
                                }
                            }
                        }
                    }
                }
            }
        }

        // Обновление таблицы лидеров (без отображения массы)
        function updateLeaderboard() {
            // Создаем массив всех объектов (боты + игрок)
            const allPlayers = [...bots.map(bot => ({
                name: bot.name,
                isPlayer: false,
                score: bot.score
            })), {
                name: player.name,
                isPlayer: true,
                score: player.score
            }];
            
            // Сортируем по очкам (по убыванию)
            allPlayers.sort((a, b) => b.score - a.score);
            
            // Берем топ-10
            const topPlayers = allPlayers.slice(0, 10);
            
            // Очищаем и обновляем таблицу лидеров
            leaderboardElement.innerHTML = '<h3>Top 10</h3>';
            topPlayers.forEach((p, index) => {
                const entry = document.createElement('div');
                entry.className = 'player-entry' + (p.isPlayer ? ' player' : '');
                entry.textContent = `${index + 1}. ${p.name}`;
                leaderboardElement.appendChild(entry);
            });
        }

        // Обновление индикатора массы
        function updateMassIndicator() {
            massIndicator.textContent = `Масса: ${Math.round(player.score)}`;
        }

        // Показать меню поражения
        function showGameOverMenu() {
            gameOverMenu.style.display = 'flex';
        }

        // Скрыть меню поражения
        function hideGameOverMenu() {
            gameOverMenu.style.display = 'none';
        }

        // Рестарт игры
        function restartGame() {
            player.x = virtualWidth / 2;
            player.y = virtualHeight / 2;
            player.radius = Math.sqrt(20 / Math.PI);
            player.score = 20;
            player.cells = [{
                x: player.x,
                y: player.y,
                radius: player.radius,
                color: player.color,
                dx: 0,
                dy: 0,
                score: player.score
            }];
            player.lastSplitTime = 0;
            player.isSplitting = false;
            
            // Очищаем ботов и создаем заново
            bots.length = 0;
            initBots();
            
            // Очищаем и заново генерируем еду
            foodParticles.length = 0;
            initFood();
            
            // Очищаем выплюнутые частицы
            ejectedParticles.length = 0;
            
            hideGameOverMenu();
        }

        // Отрисовка
        function draw() {
            // Очищаем canvas
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Сохраняем текущее состояние контекста
            ctx.save();
            
            // Применяем масштабирование (зум камеры)
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(-camera.x, -camera.y);

            drawGrid();

            // Отрисовка частиц еды
            foodParticles.forEach(food => {
                ctx.beginPath();
                ctx.arc(food.x, food.y, food.radius, 0, Math.PI * 2);
                ctx.fillStyle = food.color;
                ctx.fill();
                ctx.closePath();
            });
            
            // Отрисовка выплюнутых частиц
            ejectedParticles.forEach(particle => {
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                ctx.fillStyle = particle.color;
                ctx.fill();
                ctx.closePath();
            });

            // Отрисовка ботов
            bots.forEach(bot => {
                bot.cells.forEach(cell => {
                    ctx.beginPath();
                    ctx.arc(cell.x, cell.y, cell.radius, 0, Math.PI * 2);
                    ctx.fillStyle = cell.color;
                    ctx.fill();
                    ctx.closePath();
                    
                    // Отображение имени бота над первой клеткой
                    if (cell === bot.cells[0]) {
                        ctx.fillStyle = '#000000';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(bot.name, cell.x, cell.y + cell.radius + 15);
                    }
                });
            });

            // Отрисовка игрока
            player.cells.forEach((cell, index) => {
                ctx.beginPath();
                ctx.arc(cell.x, cell.y, cell.radius, 0, Math.PI * 2);
                ctx.fillStyle = cell.color;
                ctx.fill();
                ctx.closePath();
                
                // Отображение имени игрока над первой клеткой
                if (index === 0) {
                    ctx.fillStyle = '#000000';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(player.name, cell.x, cell.y + cell.radius + 15);
                }
            });
            
            // Восстанавливаем состояние контекста
            ctx.restore();
        }

        // Кнопка рестарта
        restartButton.addEventListener('click', restartGame);

        // Основной игровой цикл
        function gameLoop() {
            updatePlayer();
            updateCamera();
            updateEjectedParticles();
            updateBots();
            checkFoodCollection();
            checkCollisions();
            updateLeaderboard();
            updateMassIndicator();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Инициализация игры
        function initGame() {
            initBots();
            initFood();
            spawnFoodRegularly();
            gameLoop();
        }

        // Запуск игры при загрузке
        window.addEventListener('load', initGame);

        // Обработка изменения размера окна
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>
